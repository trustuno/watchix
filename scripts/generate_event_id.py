#!/usr/bin/env python3
import re
import os

# File paths
EVENT_LIST_FILE = 'core/event_manager/event_list.h'
OUTPUT_FILE = 'include/event_manager/event_id.h'


def parse_event_groups():
    """Parses the event groups and returns a dictionary {group_name: group_id}."""
    groups = {}
    inside_enum = False

    with open(EVENT_LIST_FILE, 'r') as file:
        for line in file:
            line = line.strip()

            if line.startswith("enum EventGroup"):
                inside_enum = True
                continue

            if inside_enum:
                if line.startswith("};"):
                    break

                match = re.match(r'(\w+)\s*=\s*0x([0-9A-Fa-f]+)', line)
                if match:
                    group_name = match.group(1).replace('_GROUP', '')
                    group_id = int(match.group(2), 16)
                    groups[group_name] = group_id

    return groups


def parse_group_events(group_name):
    """Parses all events for a specific group and returns a list of event names."""
    events = []
    inside_enum = False

    with open(EVENT_LIST_FILE, 'r') as file:
        for line in file:
            line = line.strip()

            if line.startswith(f"enum {group_name} "):
                inside_enum = True
                continue

            if inside_enum:
                if line.startswith("};"):
                    break

                # Match: EVENT_NAME = <value> OR EVENT_NAME
                match = re.match(r'(\w+)\s*(=\s*\d+)?\s*,?', line)
                if match:
                    event_name = match.group(1)
                    events.append(event_name)

    return events


def generate_event_id_header(groups):
    """Generates the event_id.h file with aligned formatting."""
    all_entries = []

    for group_name, group_id in groups.items():
        events = parse_group_events(group_name)

        if not events:
            continue

        event_id_counter = 1
        for event in events:
            final_id = (group_id << 20) | event_id_counter
            enum_name = f"PUBLIC__{group_name}__{event}"
            hex_comment = f"///< 0x{final_id:X}"
            all_entries.append((enum_name, final_id, hex_comment))
            event_id_counter += 1

    if not all_entries:
        print("⚠️ No events found. Skipping generation.")
        return

    # Calculate maximum enum name length for alignment
    max_name_length = max(len(entry[0]) for entry in all_entries)

    # Start generating header file
    lines = []
    lines.append("#ifndef EVENT_ID_H")
    lines.append("#define EVENT_ID_H\n")
    lines.append("/**")
    lines.append(" * @file event_id.h")
    lines.append(" * @brief Auto-generated event ID list for plugins.")
    lines.append(" * @note Do not edit this file manually. Generated by generate_event_id.py.")
    lines.append(" */\n")
    lines.append("enum EventID {")

    current_group = ""
    for enum_name, final_id, hex_comment in all_entries:
        group = enum_name.split("__")[1]
        if group != current_group:
            if current_group != "":
                lines.append("")  # Add spacing between groups
            lines.append(f"    // Events for {group}_EVENT_GROUP")
            current_group = group

        padding = ' ' * (max_name_length - len(enum_name) + 1)
        lines.append(f"    {enum_name}{padding}= 0x{final_id:08X}, {hex_comment}")

    lines.append("};\n")
    lines.append("#endif // EVENT_ID_H\n")

    os.makedirs(os.path.dirname(OUTPUT_FILE), exist_ok=True)
    with open(OUTPUT_FILE, 'w') as file:
        file.write("\n".join(lines))

    print(f"✅ Generated {OUTPUT_FILE} successfully with aligned enums.")


if __name__ == "__main__":
    groups = parse_event_groups()
    if not groups:
        print("⚠️ No event groups found. Skipping generation.")
    else:
        generate_event_id_header(groups)
